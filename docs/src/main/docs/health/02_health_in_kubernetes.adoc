///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Health checks in Kubernetes
:description: Kubernetes probes
:keywords: helidon, readiness, liveliness, probes, kubernetes
:kubernetes-probes-url: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes

This document describes usages of the Helidon health check API with Kubernetes

== Kubernetes probes

Probes is the term used by Kubernetes to describe health checks for containers.

There are 2 types of probes:
* liveness: Indicates whether the container is running
* readiness: Indicates whether the container is ready to service requests

For a liveness probe, giving up means the pod will be restarted. For a readiness
 probe, giving up means not routing traffic to the pod, but the pod is not
 restarted.

Probes can be implemented with 3 different mechanisms:
. Running a command inside a container
. Making an `HTTP` request against a container
. Opening a `TCP` socket against a container

You can read more information about the Kubernetes probes
 link:{kubernetes-probes-url}[here].

A microservice exposed to HTTP will typically implement both the liveness probe
 and the readiness probe using HTTP requests.

Probes can be configured with different parameters, see the most relevant
 ones below:

[cols="2"]
|=======
| `initialDelaySeconds`
| Number of seconds before probes are initiated

| `periodSeconds`
| How often to perform the probe. Default to 10 seconds. Minimum value is 1

| `timeoutSeconds`
| Number of seconds after which the probe times out. Defaults to 1 second.
 Minimum value is 1

| `failureThreshold`
| Number of failed probes before giving up. Defaults to 3. Minimum value is 1.
|=======

The liveness probe is used to verify the container has become unresponsive.
A bad liveness probe can result in repeated restarts.

TIP:
* Avoid checking dependencies in a liveness probe
* Set `timeoutSeconds` to avoid excessive probe failures
* Acknowledge startup times with `initDelaysSeconds`

The readiness probe is used to avoid routing requests to the pod until it is
 ready to accept traffic. A bad readiness probe can result in a cascading effect
 where all pods are removed from the service routing

TIP:
* Be conservative when checking shared dependencies
* Be aggressive when checking local dependencies
* Set `failureThreshold` according to `periodSeconds`, to accomodate temporary
 errors

[source,yaml]
.Example pod with probes
----
spec:
  containers:
  - name: acme-app
    image: ocir.io/acme-app
    livenessProbe:
      httpGet:
        path: /live # <1>
        port: 8080
      initialDelaySeconds: 3 # <2>
      periodSeconds: 10
      timeoutSeconds: 3
      failureThreshold: 3
    readinessProbe:
      httpGet:
        path: /ready # <3>
        port: 8080
      initialDelaySeconds: 10 # <4>
      periodSeconds: 30
      timeoutSeconds: 10
----
<1> The HTTP endpoint for the liveness probe
<2> The liveness probe configuration
<4> The HTTP endpoint for the readiness probe
<5> The readiness probe configuration

== Probes logs

TODO:
* explain how successful probes are logged at level 4 and only available in
 kubelet logs
* explain that failed probes are emitted as event, show how to get the response
 body for failed probes

== Example

TODO:
* show how to do a different port
* show how to do 2 different health check endpoints (`/live` and `/ready`)
* show that built-in health checks are suitable for liveness
* simulate a readiness check for a DB